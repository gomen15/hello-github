스프링 부트

pathvariable은 {} 사용

dto는 다른 레이어간의 데이터 교환. 
각 클래스 및 인터페이스를 호출하면서 전달하는 매개변수로 사용되는 데이터 객체
dto는 데이터를 교환하는 용도로만 사용 별도의 로직이 포함 되지 않는다

dto 와vo(Value Object)의 역할을 서로 엄밀하게 구분하지 않고 사용할 때가 많다.
vo는 데이터 그자체로 의미가 있는 객체.
vo의 가장 특징적인 부분은 읽기전용으로 설계한다는 점. 즉  vo는 값을 변경할 수 없게 만들어 데이터의 신뢰성을 유지 해야한다

dto는 데이터전송을 위해 사용되는 데이터 컨테이너로 볼 수 있다. 즉 같은 애플리케이션 내부에서 사용되는 것이 아니라 다른 서버로 전달하는 경우에 사용
dto - getter/setter.

@NonNull : null을 허용하지 않을 경우
 @Nullable : null을 허용할 경우

클라이언트에서  서버로 통신하는 메시지를 요청메시지라고하며, 서버에서 클라이언트로 통신하는 메시지를 응답메시지라고한다.
웹에서 화면전환(새로고침)없이 이루어지는 동작들은 대부분 비동기통신으로 이루어진다.
비동기통신을 하기위해서는 클라이언트에서 서버로 요청 메시지를 보낼 때, 본문에 데이터를 담아서 보내야하고, 
서버에서 클라이언트로 응답을 보낼 때에도 본문에 데이터를 담아서 보내야한다
이 본문이 바로 body.
즉 요청본문 requestBody,응답본문resonseBody을 담아서 보내야한다

비동기식 클라-서버 통신을 위해JSON형식의 데이터를 주고받는것

일반적인 get/post요청 파라미터라면 @RequestBody를 사용할 일이 없을것.
반면에 xml이나 json기  반의 메시지를 사용하는 요청의 경우에 이 방법이 매우 용하다.

ResponseEntity란

Spring Framework에서 제공하는 클래스 중 HttpEntity라는 클래스가 존재한다.
이것은 HTTP요청 또는 응답에 해당하는 HttpHeader 와 HttpBody를 포함한 클래스이다.
HttpEntity 클래스를 상속받아 구현한 클래스가 RequestEntity, ResponseEntity클래스.
따라서 HttpStatus,HttpHeaders,HttpBody를 포함한다.

로깅(logging)이란 애플리케이션이 동작하는 동안  시스템의 상태나 동작 정보를 시간순으로 기록하는 것.
로깅은 개발 영역중 '비기능 요구사항'에 속한다. 자바 진영에서 가장 많이 사용되는 로깅 프레임워크는 LogBack.
Logback이란 log4j이후에 출시된 로깅 프레이워크로서 slf4j를 기반으로 구현 과거에 사용되던  log4j에 비해 월등한 성능.
또한 스프링 부트의 라이브러리 내부에 내장돼있어 별도의 di 필요 없음.
Logback특징-
ERROR: 뢰직 수행중에 시스템에 심각한 문제가 발생해서 애플리케이션의 작동이 불가능한 경우.
WARN: 시스템 에러의 원인이 될 수 있는 경고
INFO: 애플리케이션ㄴ의 상태변경과 같은 정보 전달
DEBUG: 애플리케이션의 디버깅을 위한 메시지를 표시
TRACE:DEBUG 레벨보다 더 상세한 메시지 표현


ORM(Object Relational Mapping) 객체 고ㅠㅏㄴ계 매핑. 
자바와 같은 객체지향 언어에서 의미하는 객체와 RDB의 테이블을 자동으로 매핑
객체지향언에서의 객체는 클래스를 의미. 클래스는 데이터베이스의 테이블과 매핑하기 위해 만들어진 것이 아니기 때문에 
RDB테이블과 어쩔수 없느 불일치가 존재. ORM은 이둘의 불일치와 제약사항을 해결하는 역할.
ORM장점:
]데이터베이스 쿼리를 객체지향적으로 조작
]재사용및유지보수가 편리
]데이터베이스에 대한 종속성 줄어든다
단점:
]ORM만으로 온전한 서비스를 구현하기에는 한계가 있습니다.
복잡한 서비스의 경우 직접 쿼리를 구현하지않고 코드로 구현하기 어렵습니다.
]애플리케이션의 객체 관점과 데이터베이스의 관계 관점의 불일치가 발생합니다.
세분성:ORM의 자동 설계 방법에 따라 데이터베이스에 있는 테이블의 수와 애플리케이션의 엔티티 클래스의 수가 다른 경우 생깁니다.(클래스가 테이블의 수보다 많아질 수 있습니다.)
상속성:RDBMS에는 상속이라는 개념이 없다
식별성:RDBMS는 기본키로 동일성의 정의.하지만 자바는 두 객체의 값이 같아도 다르다고 판단 할 수 있습니다.
연관성: 객체지항 언어는 객체를 참조함으로써 연관성을 나타내지만RDBMS 에서는 외래키를 삽입함으로 연관성 표현.
탐색: 자바와RDMBS는 어떤 값에 접근하는 방식이 다릅니다.자바에서는 특정 값에 접근하기 위해 객체 참조같ㅇ은 연ㄱㄹ수단 활용.
이방식은 객체를 연결하고 또 연결해서 접근하는 그래프 형태의 접근방식. 반면 RDBMS에서는 쿼리를 최소화하고 JOIN을 통해 여러 테이블을 로드하고 값을추출

JPA는 자바 진영의ORM기술 표준으로 채택된 인터페이스의 모음.
ORM이 큰 개념이라면 JPA는 더 구체화된 스펙 포함. 
JPA의 매커니즘을 보면 니부적으로 JDBC사용. 개발자가 직접 JDBC를 구현하면 SQL에 의존하게 되는 문제등이 있어.
효울이 떨어지는데, JPA는 이같은 문제점을 보완해 적절한 SQL생성하고 데이터베이스를 조작해서 객체를 자동매핑.
JPA기반의 구현체는 대표적으로 세가지- Hibernate, EclipseLink, DataNucleus 그중 가장 많이 사용은 하이버네이트.

하이버네이트는 자바의 ORM프레임워크로서, JPA가 정의하는 인터페이스를 구현하고 있는 JPA구현체중 하나입니다.

Spring Data JPA는 CRUD 처리에 필요한 인터페이스 제공, 하이버네이트의 엔티티 매니저를 직접 다루지 않고 리포지토리를 정의해 사용함으로써
스프링이 적합한 쿼리를 동적으로 생성하느 방식으로 데이터베이스를 조작.

영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능 수행.
엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업을 수행.
엔티티 개체가 영속성 컨텍스트에 들어와 JPA의 관리대상이 되는 시점부터는 해당 객체를 영속 객체라고 부릅니다.
영속성 컨텍스트는 세션 단위의 생명주기를 가집니다. 데이터베이스에 접근하기 위한 세션이 생성되면
영속성 컨텍스트가 만들어지고 세션이 종료되면 영속성 컨텍스트도 없어집니다. 엔티티 매니저는 이러한 일련의 과정에서
영속성 컨텍스트에 접근하기 위한 수단

엔티티는 데이터베이스 테이블이라고 생각하면 이해가 편하다

엔티티 매니저는 엔티티 관리하는 객체.
엔티티 매니저는 데이터베이스에 접근해서 CRUD작업 수행

dao 와 리포지토리는 역할ㅇ ㅣ비슷. 실제로 리포지토리는 Spring Data JPA에서 제공하는 기능이기 때문에 기존의 스프링 프레임워크나
스프링MVC의 사용자는 리포지토리라는 개념을 사용하지 않고DAO객체로 데이터베이스에 접근. 